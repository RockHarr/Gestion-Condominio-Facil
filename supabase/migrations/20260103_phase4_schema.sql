-- Enable btree_gist for exclusion constraints
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- Drop existing tables and types to ensure clean slate for Phase 4
DROP TABLE IF EXISTS poll_responses CASCADE;
DROP TABLE IF EXISTS polls CASCADE;
DROP TABLE IF EXISTS incidents CASCADE;
DROP TABLE IF EXISTS deposit_decisions CASCADE;
DROP TABLE IF EXISTS reservations CASCADE;
DROP TABLE IF EXISTS reservation_types CASCADE;
DROP TABLE IF EXISTS amenities CASCADE;

DROP TYPE IF EXISTS poll_results_visibility CASCADE;
DROP TYPE IF EXISTS weighting_strategy CASCADE;
DROP TYPE IF EXISTS incident_status CASCADE;
DROP TYPE IF EXISTS deposit_decision_type CASCADE;
DROP TYPE IF EXISTS reservation_status CASCADE;

-- Enums
CREATE TYPE reservation_status AS ENUM ('REQUESTED', 'REJECTED', 'APPROVED_PENDING_PAYMENT', 'CONFIRMED', 'CANCELLED', 'COMPLETED', 'NO_SHOW');
CREATE TYPE deposit_decision_type AS ENUM ('RELEASE', 'RETAIN_PARTIAL', 'RETAIN_FULL');
CREATE TYPE incident_status AS ENUM ('DRAFT', 'APPROVED', 'CHARGED');
CREATE TYPE weighting_strategy AS ENUM ('UNIT', 'ALICUOTA');
CREATE TYPE poll_results_visibility AS ENUM ('LIVE', 'CLOSED');

-- Units (New table to normalize units)
CREATE TABLE IF NOT EXISTS units (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    alicuota NUMERIC DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Migrate existing units from profiles if needed
-- This assumes profiles has a 'unidad' text column.
-- We insert unique values from profiles.unidad into units.
INSERT INTO units (name)
SELECT DISTINCT unidad FROM profiles 
WHERE unidad IS NOT NULL AND unidad != ''
ON CONFLICT (name) DO NOTHING;

-- Add unit_id to profiles if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'unit_id') THEN
        ALTER TABLE profiles ADD COLUMN unit_id BIGINT REFERENCES units(id) ON DELETE SET NULL;
        
        -- Link existing profiles to units
        UPDATE profiles p
        SET unit_id = u.id
        FROM units u
        WHERE p.unidad = u.name;
    END IF;
END $$;

-- Amenities
CREATE TABLE amenities (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    capacity INTEGER,
    photo_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Reservation Types
CREATE TABLE reservation_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    amenity_id BIGINT REFERENCES amenities(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    fee_amount NUMERIC NOT NULL DEFAULT 0,
    deposit_amount NUMERIC NOT NULL DEFAULT 0,
    max_duration_minutes INTEGER,
    min_advance_hours INTEGER,
    form_schema JSONB, -- Defines the fields required
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Reservations
CREATE TABLE reservations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    amenity_id BIGINT REFERENCES amenities(id) ON DELETE CASCADE NOT NULL,
    type_id BIGINT REFERENCES reservation_types(id) ON DELETE SET NULL,
    unit_id BIGINT REFERENCES units(id) ON DELETE CASCADE, -- Nullable for system blocks
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Who made the request
    start_at TIMESTAMP WITH TIME ZONE NOT NULL,
    end_at TIMESTAMP WITH TIME ZONE NOT NULL,
    status reservation_status NOT NULL DEFAULT 'REQUESTED',
    is_system BOOLEAN NOT NULL DEFAULT FALSE,
    system_reason TEXT,
    form_data JSONB, -- Snapshot of answers
    fee_snapshot NUMERIC, -- Snapshot of price
    deposit_snapshot NUMERIC, -- Snapshot of deposit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT check_dates CHECK (end_at > start_at),
    CONSTRAINT check_system_unit CHECK (
        (is_system = TRUE AND unit_id IS NULL) OR 
        (is_system = FALSE AND unit_id IS NOT NULL)
    )
);

-- Exclusion Constraint for Anti-Overlap
ALTER TABLE reservations
ADD CONSTRAINT no_overlap_reservations
EXCLUDE USING GIST (
    amenity_id WITH =,
    tstzrange(start_at, end_at) WITH &&
)
WHERE (status IN ('REQUESTED', 'APPROVED_PENDING_PAYMENT', 'CONFIRMED') OR is_system = TRUE);

-- Deposit Decisions
CREATE TABLE deposit_decisions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    reservation_id BIGINT REFERENCES reservations(id) ON DELETE CASCADE NOT NULL UNIQUE,
    decision deposit_decision_type NOT NULL,
    retained_amount NUMERIC DEFAULT 0,
    reason TEXT,
    decided_by UUID REFERENCES auth.users(id),
    decided_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT check_retained_reason CHECK (
        (decision IN ('RETAIN_PARTIAL', 'RETAIN_FULL') AND reason IS NOT NULL) OR
        (decision = 'RELEASE')
    )
);

-- Incidents
CREATE TABLE incidents (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    reservation_id BIGINT REFERENCES reservations(id) ON DELETE CASCADE NOT NULL,
    description TEXT NOT NULL,
    evidence_urls TEXT[],
    regulation_ref TEXT,
    fine_amount NUMERIC DEFAULT 0,
    status incident_status DEFAULT 'DRAFT',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Polls
CREATE TABLE polls (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question TEXT NOT NULL,
    options JSONB NOT NULL, -- Array of strings or objects
    start_at TIMESTAMP WITH TIME ZONE NOT NULL,
    end_at TIMESTAMP WITH TIME ZONE NOT NULL,
    weighting_strategy weighting_strategy NOT NULL DEFAULT 'UNIT',
    show_results_when poll_results_visibility NOT NULL DEFAULT 'CLOSED',
    weight_snapshot_json JSONB, -- Snapshot of alicuotas {unit_id: weight}
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Poll Responses
CREATE TABLE poll_responses (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    poll_id BIGINT REFERENCES polls(id) ON DELETE CASCADE NOT NULL,
    unit_id BIGINT REFERENCES units(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    option_index INTEGER NOT NULL, -- Index in the options array
    weight_used NUMERIC NOT NULL DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    UNIQUE(poll_id, unit_id)
);

-- RLS Policies

-- Amenities: Everyone can read, Admin can all
ALTER TABLE amenities ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read amenities" ON amenities FOR SELECT USING (true);
CREATE POLICY "Admin all amenities" ON amenities FOR ALL USING (auth.role() = 'authenticated' AND (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');

-- Reservation Types: Everyone can read, Admin can all
ALTER TABLE reservation_types ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read types" ON reservation_types FOR SELECT USING (true);
CREATE POLICY "Admin all types" ON reservation_types FOR ALL USING (auth.role() = 'authenticated' AND (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');

-- Reservations: 
-- Residents can view their own + all system blocks + all confirmed/approved (anonymized via frontend, but row access needed for calendar)
-- Actually, for calendar, we need to see occupied slots.
-- Let's allow reading all reservations, but frontend will hide details of others.
-- OR better: Create a view for availability. For now, simple RLS.
ALTER TABLE reservations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Read all reservations" ON reservations FOR SELECT USING (true); -- Needed for calendar
CREATE POLICY "Admin all reservations" ON reservations FOR ALL USING (auth.role() = 'authenticated' AND (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');
-- Residents CANNOT insert directly (must use RPC)
-- Residents can update ONLY their own if REQUESTED (e.g. cancel) - Optional, maybe RPC only too.

-- Polls: Read all, Admin all
ALTER TABLE polls ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Read all polls" ON polls FOR SELECT USING (true);
CREATE POLICY "Admin all polls" ON polls FOR ALL USING (auth.role() = 'authenticated' AND (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');

-- Poll Responses: Read own, Admin all
ALTER TABLE poll_responses ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Read own responses" ON poll_responses FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Admin all responses" ON poll_responses FOR ALL USING (auth.role() = 'authenticated' AND (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');
-- Insert via RPC or direct if policy allows. Let's allow direct insert for now with check.
CREATE POLICY "Insert own response" ON poll_responses FOR INSERT WITH CHECK (auth.uid() = user_id);

-- RPC: request_reservation
CREATE OR REPLACE FUNCTION request_reservation(
    p_amenity_id BIGINT,
    p_type_id BIGINT,
    p_start_at TIMESTAMP WITH TIME ZONE,
    p_end_at TIMESTAMP WITH TIME ZONE,
    p_form_data JSONB
) RETURNS BIGINT AS $$
DECLARE
    v_unit_id BIGINT;
    v_user_id UUID;
    v_is_morose BOOLEAN;
    v_fee NUMERIC;
    v_deposit NUMERIC;
    v_reservation_id BIGINT;
BEGIN
    v_user_id := auth.uid();
    
    -- Get Unit ID
    SELECT unit_id INTO v_unit_id FROM profiles WHERE id = v_user_id;
    IF v_unit_id IS NULL THEN
        RAISE EXCEPTION 'User has no assigned unit';
    END IF;

    -- Check Morosity (Simplified check against units table or debt calculation)
    -- Assuming 'units' has a 'is_morose' flag or we check sum of debts.
    -- Let's assume we check 'common_expense_debts' for unpaid > 0.
    -- For now, placeholder logic or check if unit has unpaid debts > X.
    -- SELECT EXISTS(...) INTO v_is_morose ...
    
    -- Get Snapshots
    SELECT fee_amount, deposit_amount INTO v_fee, v_deposit
    FROM reservation_types WHERE id = p_type_id;

    -- Insert
    INSERT INTO reservations (
        amenity_id, type_id, unit_id, user_id, start_at, end_at, 
        status, is_system, form_data, fee_snapshot, deposit_snapshot
    ) VALUES (
        p_amenity_id, p_type_id, v_unit_id, v_user_id, p_start_at, p_end_at,
        'REQUESTED', FALSE, p_form_data, v_fee, v_deposit
    ) RETURNING id INTO v_reservation_id;

    RETURN v_reservation_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: approve_reservation
CREATE OR REPLACE FUNCTION approve_reservation(p_reservation_id BIGINT) RETURNS VOID AS $$
DECLARE
    v_res RECORD;
BEGIN
    -- Check Admin
    IF NOT (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin' THEN
        RAISE EXCEPTION 'Not authorized';
    END IF;

    SELECT * INTO v_res FROM reservations WHERE id = p_reservation_id;
    
    -- Re-check Overlap (handled by Exclusion Constraint on Update)
    
    -- Update Status
    UPDATE reservations SET status = 'APPROVED_PENDING_PAYMENT' WHERE id = p_reservation_id;
    
    -- Create Charges (Assuming 'charges' table exists)
    -- INSERT INTO charges (unit_id, amount, description, type, status, reference_id) ...
    
    -- Placeholder for charge creation logic
    -- INSERT INTO charges (unit_id, amount, description, type, status, reference_id)
    -- VALUES (v_res.unit_id, v_res.fee_snapshot, 'Reserva: ' || v_res.id, 'COMMON_EXPENSE', 'PENDING', v_res.id);
    
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: confirm_reservation_payment (Trigger)
CREATE OR REPLACE FUNCTION confirm_reservation_payment() RETURNS TRIGGER AS $$
DECLARE
    v_reservation_id BIGINT;
    v_all_paid BOOLEAN;
BEGIN
    -- Assuming charges table has a reference_id to reservation
    -- and type in ('RESERVATION_FEE', 'RESERVATION_DEPOSIT')
    
    -- This logic depends on how charges are linked. 
    -- Let's assume we can find the reservation_id from the charge.
    
    -- For now, this is a placeholder for the logic:
    -- IF (SELECT count(*) FROM charges WHERE reference_id = NEW.reference_id AND status != 'PAID') = 0 THEN
    --    UPDATE reservations SET status = 'CONFIRMED' WHERE id = NEW.reference_id;
    -- END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: close_reservation
CREATE OR REPLACE FUNCTION close_reservation(p_reservation_id BIGINT, p_status reservation_status) RETURNS VOID AS $$
BEGIN
    -- Check Admin
    IF NOT (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin' THEN
        RAISE EXCEPTION 'Not authorized';
    END IF;

    IF p_status NOT IN ('COMPLETED', 'NO_SHOW') THEN
        RAISE EXCEPTION 'Invalid status for closing';
    END IF;

    UPDATE reservations SET status = p_status WHERE id = p_reservation_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: decide_deposit
CREATE OR REPLACE FUNCTION decide_deposit(
    p_reservation_id BIGINT, 
    p_decision deposit_decision_type, 
    p_retained_amount NUMERIC, 
    p_reason TEXT
) RETURNS VOID AS $$
DECLARE
    v_res_status reservation_status;
BEGIN
    -- Check Admin
    IF NOT (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin' THEN
        RAISE EXCEPTION 'Not authorized';
    END IF;

    SELECT status INTO v_res_status FROM reservations WHERE id = p_reservation_id;
    
    IF v_res_status NOT IN ('COMPLETED', 'NO_SHOW') THEN
        RAISE EXCEPTION 'Reservation must be COMPLETED or NO_SHOW';
    END IF;

    INSERT INTO deposit_decisions (reservation_id, decision, retained_amount, reason, decided_by)
    VALUES (p_reservation_id, p_decision, p_retained_amount, p_reason, auth.uid());
    
    -- Update Charge Status (Placeholder)
    -- UPDATE charges SET status = ... WHERE reference_id = p_reservation_id AND type = 'RESERVATION_DEPOSIT';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: submit_vote
CREATE OR REPLACE FUNCTION submit_vote(p_poll_id BIGINT, p_option_index INTEGER) RETURNS VOID AS $$
DECLARE
    v_unit_id BIGINT;
    v_weight NUMERIC := 1;
    v_strategy weighting_strategy;
    v_snapshot JSONB;
BEGIN
    -- Get Unit ID
    SELECT unit_id INTO v_unit_id FROM profiles WHERE id = auth.uid();
    IF v_unit_id IS NULL THEN
        RAISE EXCEPTION 'User has no assigned unit';
    END IF;

    -- Check if already voted (Constraint handles this, but nice to check)
    
    -- Get Strategy and Snapshot
    SELECT weighting_strategy, weight_snapshot_json INTO v_strategy, v_snapshot 
    FROM polls WHERE id = p_poll_id;

    -- Calculate Weight
    IF v_strategy = 'ALICUOTA' AND v_snapshot IS NOT NULL THEN
        -- Extract weight from snapshot for this unit
        -- v_weight := (v_snapshot->>v_unit_id::text)::numeric;
        -- Fallback to 1 if not found? Or error?
        v_weight := COALESCE((v_snapshot->>v_unit_id::text)::numeric, 1);
    END IF;

    INSERT INTO poll_responses (poll_id, unit_id, user_id, option_index, weight_used)
    VALUES (p_poll_id, v_unit_id, auth.uid(), p_option_index, v_weight);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
