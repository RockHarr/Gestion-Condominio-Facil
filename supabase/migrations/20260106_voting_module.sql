-- 1. FIX: Update Exclusion Constraint for System Blocks
-- Previous constraint included 'OR is_system = TRUE' which caused CANCELLED system blocks to still block.
-- We change it to rely solely on status, as system blocks are created with status 'CONFIRMED'.

ALTER TABLE reservations DROP CONSTRAINT IF EXISTS no_overlap_reservations;

ALTER TABLE reservations
ADD CONSTRAINT no_overlap_reservations
EXCLUDE USING GIST (
    amenity_id WITH =,
    tstzrange(start_at, end_at) WITH &&
)
WHERE (status IN ('REQUESTED', 'APPROVED_PENDING_PAYMENT', 'CONFIRMED'));


-- 2. VOTING MODULE SCHEMA

-- Update Polls Table
ALTER TABLE polls 
ADD COLUMN IF NOT EXISTS weighting_strategy weighting_strategy NOT NULL DEFAULT 'UNIT',
ADD COLUMN IF NOT EXISTS show_results_when poll_results_visibility NOT NULL DEFAULT 'CLOSED',
ADD COLUMN IF NOT EXISTS weight_snapshot_json JSONB,
ADD COLUMN IF NOT EXISTS closed_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS closed_by UUID REFERENCES auth.users(id),
ADD COLUMN IF NOT EXISTS close_reason TEXT;

-- Add check for close reason
ALTER TABLE polls DROP CONSTRAINT IF EXISTS check_close_reason;
ALTER TABLE polls ADD CONSTRAINT check_close_reason CHECK (
    (closed_at IS NULL) OR (closed_at IS NOT NULL AND close_reason IS NOT NULL)
);

-- Poll Options Table (Re-creating to ensure structure)
DROP TABLE IF EXISTS poll_options CASCADE;
CREATE TABLE poll_options (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    poll_id BIGINT REFERENCES polls(id) ON DELETE CASCADE NOT NULL,
    option_text TEXT NOT NULL,
    option_index INTEGER NOT NULL,
    UNIQUE(poll_id, option_index)
);

-- Poll Responses Table (Re-creating to ensure structure)
DROP TABLE IF EXISTS poll_responses CASCADE;
CREATE TABLE poll_responses (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    poll_id BIGINT REFERENCES polls(id) ON DELETE CASCADE NOT NULL,
    unit_id BIGINT REFERENCES units(id) ON DELETE CASCADE NOT NULL,
    option_id BIGINT REFERENCES poll_options(id) ON DELETE CASCADE NOT NULL,
    weight_used NUMERIC NOT NULL DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    UNIQUE(poll_id, unit_id)
);

-- RLS for Voting
ALTER TABLE polls ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public read polls" ON polls;
CREATE POLICY "Public read polls" ON polls FOR SELECT USING (true);
DROP POLICY IF EXISTS "Admin all polls" ON polls;
CREATE POLICY "Admin all polls" ON polls FOR ALL USING (public.is_admin());

ALTER TABLE poll_options ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public read options" ON poll_options;
CREATE POLICY "Public read options" ON poll_options FOR SELECT USING (true);
DROP POLICY IF EXISTS "Admin all options" ON poll_options;
CREATE POLICY "Admin all options" ON poll_options FOR ALL USING (public.is_admin());

ALTER TABLE poll_responses ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Admin all responses" ON poll_responses;
CREATE POLICY "Admin all responses" ON poll_responses FOR ALL USING (public.is_admin());
-- Residents cannot select responses directly to prevent seeing others' votes (even if anonymized, aggregate via RPC is safer)
-- But they need to see if they voted? No, we can check via RPC or a specific "my_vote" function.
-- For now, allow reading OWN response.
DROP POLICY IF EXISTS "Read own response" ON poll_responses;
CREATE POLICY "Read own response" ON poll_responses FOR SELECT USING (
    unit_id IN (SELECT unit_id FROM profiles WHERE id = auth.uid())
);


-- 3. RPCs

-- RPC: create_poll
CREATE OR REPLACE FUNCTION create_poll(
    p_question TEXT,
    p_options TEXT[], -- Array of option texts
    p_start_at TIMESTAMP WITH TIME ZONE,
    p_end_at TIMESTAMP WITH TIME ZONE,
    p_strategy weighting_strategy,
    p_show_results_when poll_results_visibility
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_poll_id BIGINT;
    v_snapshot JSONB := NULL;
    v_opt TEXT;
    v_idx INT := 0;
BEGIN
    -- Check Admin
    IF NOT public.is_admin() THEN
        RAISE EXCEPTION 'Only admins can create polls';
    END IF;

    -- Validate Dates
    IF p_end_at <= p_start_at THEN
        RAISE EXCEPTION 'End date must be after start date';
    END IF;

    -- Generate Snapshot if Alicuota
    IF p_strategy = 'ALICUOTA' THEN
        SELECT jsonb_object_agg(id, alicuota) INTO v_snapshot FROM units;
    END IF;

    -- Insert Poll
    INSERT INTO polls (
        question, start_at, end_at, weighting_strategy, show_results_when, weight_snapshot_json, created_by, options
    ) VALUES (
        p_question, p_start_at, p_end_at, p_strategy, p_show_results_when, v_snapshot, auth.uid(), '[]'::jsonb -- options col legacy/unused, using table now
    ) RETURNING id INTO v_poll_id;

    -- Insert Options
    FOREACH v_opt IN ARRAY p_options
    LOOP
        INSERT INTO poll_options (poll_id, option_text, option_index)
        VALUES (v_poll_id, v_opt, v_idx);
        v_idx := v_idx + 1;
    END LOOP;

    RETURN jsonb_build_object('id', v_poll_id, 'status', 'SUCCESS');
END;
$$;


-- RPC: submit_vote
CREATE OR REPLACE FUNCTION submit_vote(
    p_poll_id BIGINT,
    p_option_id BIGINT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_unit_id BIGINT;
    v_poll_start TIMESTAMP WITH TIME ZONE;
    v_poll_end TIMESTAMP WITH TIME ZONE;
    v_strategy weighting_strategy;
    v_snapshot JSONB;
    v_weight NUMERIC := 1;
    v_closed_at TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Get Unit ID
    SELECT unit_id INTO v_unit_id FROM profiles WHERE id = auth.uid();
    IF v_unit_id IS NULL THEN
        RAISE EXCEPTION 'User has no assigned unit';
    END IF;

    -- Get Poll Details
    SELECT start_at, end_at, weighting_strategy, weight_snapshot_json, closed_at
    INTO v_poll_start, v_poll_end, v_strategy, v_snapshot, v_closed_at
    FROM polls WHERE id = p_poll_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Poll not found';
    END IF;

    -- Validate Window
    -- Use v_closed_at if present as the effective end time? 
    -- Logic: If closed_at is set, the poll is closed.
    IF v_closed_at IS NOT NULL THEN
        RAISE EXCEPTION 'Poll is closed';
    END IF;

    IF now() < v_poll_start OR now() >= v_poll_end THEN
        RAISE EXCEPTION 'Voting is not currently active for this poll';
    END IF;

    -- Validate Option belongs to Poll
    PERFORM 1 FROM poll_options WHERE id = p_option_id AND poll_id = p_poll_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid option for this poll';
    END IF;

    -- Calculate Weight
    IF v_strategy = 'ALICUOTA' THEN
        IF v_snapshot IS NULL THEN
             RAISE EXCEPTION 'Snapshot missing for ALICUOTA strategy';
        END IF;
        -- Get weight from snapshot
        -- JSON keys are text, so cast unit_id to text
        v_weight := (v_snapshot->>v_unit_id::text)::numeric;
        
        IF v_weight IS NULL THEN
            RAISE EXCEPTION 'Unit weight not found in snapshot';
        END IF;
    END IF;

    -- Insert Vote (Unique constraint handles double voting)
    INSERT INTO poll_responses (poll_id, unit_id, option_id, weight_used)
    VALUES (p_poll_id, v_unit_id, p_option_id, v_weight);

    RETURN jsonb_build_object('status', 'SUCCESS', 'weight_used', v_weight);
END;
$$;


-- RPC: close_poll_early
CREATE OR REPLACE FUNCTION close_poll_early(
    p_poll_id BIGINT,
    p_reason TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_end_at TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Check Admin
    IF NOT public.is_admin() THEN
        RAISE EXCEPTION 'Only admins can close polls';
    END IF;

    IF p_reason IS NULL OR trim(p_reason) = '' THEN
        RAISE EXCEPTION 'Reason is required for early closure';
    END IF;

    -- Update Poll
    UPDATE polls
    SET closed_at = now(),
        closed_by = auth.uid(),
        close_reason = p_reason,
        end_at = now() -- Update end_at to reflect closure
    WHERE id = p_poll_id AND closed_at IS NULL
    RETURNING end_at INTO v_end_at;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Poll not found or already closed';
    END IF;

    RETURN jsonb_build_object('status', 'SUCCESS', 'closed_at', v_end_at);
END;
$$;


-- RPC: get_poll_results
CREATE OR REPLACE FUNCTION get_poll_results(p_poll_id BIGINT)
RETURNS TABLE (
    option_id BIGINT,
    option_text TEXT,
    votes_count BIGINT,
    weighted_sum NUMERIC,
    percentage NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_show_when poll_results_visibility;
    v_end_at TIMESTAMP WITH TIME ZONE;
    v_total_weight NUMERIC;
    v_is_admin BOOLEAN;
BEGIN
    v_is_admin := public.is_admin();

    SELECT show_results_when, end_at INTO v_show_when, v_end_at
    FROM polls WHERE id = p_poll_id;

    -- Visibility Check
    IF NOT v_is_admin THEN
        IF v_show_when = 'CLOSED' AND now() < v_end_at THEN
            -- Return empty or raise exception? 
            -- Better to return empty set to not break UI, or specific error?
            -- Let's return empty set implies "no results available yet"
            RETURN;
        END IF;
    END IF;

    -- Calculate Total Weight for Percentage
    SELECT COALESCE(SUM(weight_used), 0) INTO v_total_weight
    FROM poll_responses
    WHERE poll_id = p_poll_id;

    RETURN QUERY
    SELECT 
        o.id AS option_id,
        o.option_text,
        COUNT(r.id) AS votes_count,
        COALESCE(SUM(r.weight_used), 0) AS weighted_sum,
        CASE 
            WHEN v_total_weight > 0 THEN ROUND((COALESCE(SUM(r.weight_used), 0) / v_total_weight) * 100, 2)
            ELSE 0 
        END AS percentage
    FROM poll_options o
    LEFT JOIN poll_responses r ON o.id = r.option_id
    WHERE o.poll_id = p_poll_id
    GROUP BY o.id, o.option_text
    ORDER BY o.option_index;
END;
$$;
